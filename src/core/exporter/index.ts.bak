import * as XLSX from 'xlsx';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { ExportOptions } from '../../types';
import { fixPDFExport, setupChineseSupport } from './pdf-fixes';
import { applyExcelStyles } from './excel-fixes';

// 应用PDF导出修复
if (typeof window !== 'undefined') {
  setTimeout(() => {
    try {
      fixPDFExport();
    } catch (e) {
      console.warn('应用PDF导出修复失败:', e);
    }
  }, 0);
}

/**
 * 报表导出模块
 * 支持Excel和PDF格式导出
 */
export class Exporter {  /**
   * 导出为Excel
   * @param data 报表数据
   * @param options 导出选项
   */  
  static async toExcel(data: any[], options: ExportOptions = {}): Promise<void> {
    try {
      // 默认选项
      const {
        fileName = '报表',
        sheetName = 'Sheet1',
        includeHidden = false,
        styles = {} // 自定义样式选项
      } = options;
      
      // 创建工作表
      const ws = XLSX.utils.aoa_to_sheet(data);
      
      // 设置列宽
      const wscols = [];
      if (data.length > 0) {
        for (let i = 0; i < data[0].length; i++) {
          // 计算最大宽度
          let maxWidth = 10; // 默认宽度
          data.forEach(row => {
            if (row[i] && String(row[i]).length > maxWidth) {
              maxWidth = Math.min(50, String(row[i]).length); // 限制最大宽度
            }
          });
          wscols.push({ wch: maxWidth });
        }
        ws['!cols'] = wscols;
      }
      
      // 使用增强的样式功能
      applyExcelStyles(ws, data);
      
      // 创建工作簿
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
      
      // 导出文件
      XLSX.writeFile(wb, `${fileName}.xlsx`);
      
      return Promise.resolve();
    } catch (error) {
      return Promise.reject(error);
    }
  }
  /**
   * 导出为PDF
   * @param element 要导出的DOM元素
   * @param config 报表配置
   * @param options 导出选项
   */  
  static async toPDF(element: HTMLElement, config?: any, options: ExportOptions = {}): Promise<void> {
    try {
      // 默认选项
      const {
        fileName = '报表',
        watermark = '',
        pdf: pdfOptions = {}
      } = options;
      
      // 从配置中获取PDF设置，选项可以覆盖配置
      const configPdfSettings = config?.features?.pdfConfig || {};
      const mergedPdfOptions = { ...configPdfSettings, ...pdfOptions };
      
      // PDF配置
      const pageSize = mergedPdfOptions.pageSize || 'A4';
      const orientation = mergedPdfOptions.orientation || 'portrait';
      const quality = mergedPdfOptions.quality || 0.95;
      const multiPage = mergedPdfOptions.multiPage !== false;
      const relayout = mergedPdfOptions.relayout !== false; // 默认重新排版
      
      // 设置页边距(mm)
      const margins = {
        top: mergedPdfOptions.margins?.top || 15,
        right: mergedPdfOptions.margins?.right || 15,
        bottom: mergedPdfOptions.margins?.bottom || 15,
        left: mergedPdfOptions.margins?.left || 15
      };
      
      // 保存原始滚动位置
      const originalScrollTop = element.scrollTop;
      
      // 创建临时容器
      const tempContainer = element.cloneNode(true) as HTMLElement;
      tempContainer.style.position = 'absolute';
      tempContainer.style.left = '-9999px';
      tempContainer.style.overflow = 'visible';
      tempContainer.style.height = 'auto';
      
      // 如果启用重新排版，设置PDF适合的宽度
      if (relayout) {
        // 根据PDF页面方向设置合适的宽度
        const pdfWidth = orientation === 'landscape' ? 
          (pageSize === 'A4' ? 297 : 279) : // A4横版297mm, Letter横版279mm
          (pageSize === 'A4' ? 210 : 216);  // A4竖版210mm, Letter竖版216mm
        
        // 考虑页边距，设置内容宽度(转换为px，假设96dpi)
        const contentWidthMm = pdfWidth - margins.left - margins.right;
        const contentWidthPx = Math.floor(contentWidthMm * 3.78); // 1mm ≈ 3.78px at 96dpi
        
        tempContainer.style.width = contentWidthPx + 'px';
        tempContainer.style.maxWidth = contentWidthPx + 'px';
        
        // 强制表格重新计算布局
        const tableElements = tempContainer.querySelectorAll('table');
        tableElements.forEach(table => {
          (table as HTMLElement).style.width = '100%';
          (table as HTMLElement).style.tableLayout = 'fixed';
        });
      } else {
        tempContainer.style.width = element.clientWidth + 'px';
      }
      
      document.body.appendChild(tempContainer);
      
      // 确保所有内容可见
      const headerElement = tempContainer.querySelector('.ddr-report-header') as HTMLElement;
      const footerElement = tempContainer.querySelector('.ddr-report-footer') as HTMLElement;
      const tableContainer = tempContainer.querySelector('.ddr-table-container') as HTMLElement;
      
      // 检查必要的元素是否存在
      if (!tableContainer) {
        console.warn('未找到表格容器元素，导出可能不完整');
      }
      
      // 优化DOM结构以便更好地导出
      if (tableContainer) {
        tableContainer.style.maxHeight = 'none';
        tableContainer.style.height = 'auto';
        tableContainer.style.overflow = 'visible';
        
        // 确保表格内容正确显示
        const tableElement = tableContainer.querySelector('table');
        if (tableElement) {
          // 确保表格宽度正确
          tableElement.style.width = '100%';
          
          // 确保所有单元格都有适当的边框
          const cells = tableElement.querySelectorAll('td, th');
          cells.forEach(cell => {
            (cell as HTMLElement).style.border = '1px solid #ddd';
          });
        }
      }
      
      // 优化表头和表尾
      if (headerElement) {
        headerElement.style.position = 'relative';
        headerElement.style.height = 'auto';
        headerElement.style.overflow = 'visible';
      }

      if (footerElement) {
        footerElement.style.position = 'relative';
        footerElement.style.height = 'auto';
        footerElement.style.overflow = 'visible';
      }
        // 初始化PDF
      const pdf = new jsPDF({
        orientation, 
        unit: 'mm',
        format: pageSize
      });
      
      // 设置中文支持
      setupChineseSupport(pdf);

      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      
      // 内容区域高度（减去页边距）
      const contentHeight = pageHeight - margins.top - margins.bottom;
      const contentWidth = pageWidth - margins.left - margins.right;
      
      // 设置字体大小
      pdf.setFontSize(12);
      
      if (multiPage) {
        // -------------- 多页处理 --------------
        
        // 表头高度(如果有)
        let headerHeight = 0;
        let headerCanvas;
        if (headerElement) {
          try {
            headerCanvas = await html2canvas(headerElement, {
              scale: 2.0, // 适中的清晰度
              useCORS: true,
              logging: false,
              allowTaint: true,
              backgroundColor: '#FFFFFF' // 确保背景色一致
            });
            headerHeight = (headerCanvas.height / headerCanvas.width) * contentWidth;
          } catch (e) {
            console.warn('渲染表头时出错:', e);
          }
        }
        
        // 表尾高度(如果有)
        let footerHeight = 0;
        let footerCanvas;
        if (footerElement) {
          try {
            footerCanvas = await html2canvas(footerElement, {
              scale: 2.0, // 适中的清晰度
              useCORS: true,
              logging: false,
              allowTaint: true,
              backgroundColor: '#FFFFFF' // 确保背景色一致
            });
            footerHeight = (footerCanvas.height / footerCanvas.width) * contentWidth;
          } catch (e) {
            console.warn('渲染表尾时出错:', e);
          }
        }
        
        // 提取表格部分
        const tableElement = tableContainer?.querySelector('table') || tableContainer;
        if (!tableElement) {
          throw new Error('找不到表格元素');
        }          // 将表格转换为canvas，提高清晰度
        try {
          const tableCanvas = await html2canvas(tableElement, {
            scale: 2.0, // 适中的清晰度
            useCORS: true,
            logging: false,
            allowTaint: true,
            backgroundColor: '#FFFFFF' // 确保背景色一致
          });
          
          // 计算表格宽度和高度（根据内容区域宽度等比缩放）
          const tableWidth = contentWidth;
          const tableHeight = (tableCanvas.height / tableCanvas.width) * tableWidth;
          
          // 分析表格行结构，获取行高和行位置信息
          const rows = tableElement.querySelectorAll('tr');
          const rowInfo: Array<{
            index: number;
            height: number;
            top: number;
            isHeader: boolean;
            content: string;
          }> = Array.from(rows).map((row, index) => {
            const rect = (row as HTMLElement).getBoundingClientRect();
            return {
              index,
              height: rect.height,
              top: rect.top - tableElement.getBoundingClientRect().top,
              isHeader: row.querySelector('th') !== null,
              content: (row.textContent || '').trim(),
            };
          });
          
          // 分析表格行结构，获取行高和行位置信息
          const rows = tableElement.querySelectorAll('tr');
          const rowInfo = Array.from(rows).map((row, index) => {
            const rect = (row as HTMLElement).getBoundingClientRect();
            return {
              index,
              height: rect.height,
              top: rect.top - tableElement.getBoundingClientRect().top,
              isHeader: row.querySelector('th') !== null,
              content: (row.textContent || '').trim(),
            };
          });
          
          // 计算基础可用高度（不包括头尾）
          const baseAvailableHeight = contentHeight;
          
          // 确保每页至少有一点表格内容
          const minContentHeight = 30; // 至少30mm的内容
          const minRowsPerPage = 3; // 每页至少显示3行
          
          // 计算每页可容纳的行数和分页点
          const firstPageAvailableHeight = baseAvailableHeight - (headerHeight > 0 ? headerHeight + 5 : 0);
          const normalPageAvailableHeight = baseAvailableHeight;
          const lastPageAvailableHeight = baseAvailableHeight - (footerHeight > 0 ? footerHeight + 5 : 0);
          
          // 创建页面分割点
          const pageBreakPoints = [];
          let currentPageHeight = 0;
          let currentPageRows = 0;
          let isFirstPage = true;
          let pageMaxHeight = firstPageAvailableHeight;
          
          // 跳过表头行
          const headerRowCount = rowInfo.filter(r => r.isHeader).length;
          const dataRows = rowInfo.slice(headerRowCount);
          
          // 计算每页包含哪些行
          dataRows.forEach((row, idx) => {
            const rowHeightMM = (row.height / tableCanvas.height) * tableHeight;
            
            // 如果这一行会使当前页超出高度限制，则创建新页
            if ((currentPageHeight + rowHeightMM > pageMaxHeight && currentPageRows >= minRowsPerPage) || 
                (idx === 0)) { // 确保第一行数据总是在新页面开始
              
              // 添加分页点
              if (idx > 0) {
                pageBreakPoints.push({
                  rowIndex: idx + headerRowCount,
                  yPercent: row.top / tableCanvas.height
                });
              }
              
              // 重置当前页统计
              currentPageHeight = rowHeightMM;
              currentPageRows = 1;
              
              // 更新页面高度限制
              if (isFirstPage) {
                isFirstPage = false;
                pageMaxHeight = normalPageAvailableHeight; // 切换到普通页高度限制
              }
            } else {
              // 累加行高
              currentPageHeight += rowHeightMM;
              currentPageRows++;
            }
          });
          
          // 计算总页数
          const pagesNeeded = pageBreakPoints.length + 1;
          
          // 表格各部分的图像数据
          const tableImgData = tableCanvas.toDataURL('image/jpeg', quality);
          const headerImgData = headerCanvas ? headerCanvas.toDataURL('image/jpeg', quality) : null;
          const footerImgData = footerCanvas ? footerCanvas.toDataURL('image/jpeg', quality) : null;
          
          // 逐页添加内容
          for (let page = 0; page < pagesNeeded; page++) {
            // 如果不是第一页，创建新页
            if (page > 0) {
              pdf.addPage();
            }
            
            let yOffset = margins.top;
            
            // 添加表头（只在第一页显示）
            if (headerImgData && page === 0) {
              pdf.addImage(
                headerImgData, 
                'JPEG', 
                margins.left, 
                yOffset, 
                contentWidth, 
                headerHeight
              );
              yOffset += headerHeight + 5; // 5mm的间距
            }
            
            // 计算当前页表格部分的起始位置和结束位置
            let tableStartPercent = 0;
            let tableEndPercent = 1;
            
            // 如果存在分页点
            if (pageBreakPoints.length > 0) {
              if (page === 0) {
                // 第一页：从开始到第一个分页点
                tableStartPercent = 0;
                tableEndPercent = pageBreakPoints[0].yPercent;
              } else if (page < pagesNeeded - 1) {
                // 中间页：从当前分页点到下一个分页点
                tableStartPercent = pageBreakPoints[page - 1].yPercent;
                tableEndPercent = pageBreakPoints[page].yPercent;
              } else {
                // 最后一页：从最后一个分页点到结束
                tableStartPercent = pageBreakPoints[pageBreakPoints.length - 1].yPercent;
                tableEndPercent = 1;
              }
            }
            
            // 计算源图像上对应的像素位置
            const sourceY = Math.floor(tableStartPercent * tableCanvas.height);
            const sourceHeight = Math.ceil((tableEndPercent - tableStartPercent) * tableCanvas.height);
            
            // 计算目标高度（按比例）
            const tablePartHeight = (sourceHeight / tableCanvas.height) * tableHeight;
              
              try {
                // 创建临时canvas来保存裁剪的表格部分
                const pageTableCanvas = document.createElement('canvas');
                pageTableCanvas.width = tableCanvas.width;
                pageTableCanvas.height = sourceHeight;
                
                const pageTableCtx = pageTableCanvas.getContext('2d');
                if (pageTableCtx) {
                  // 将表格对应部分裁剪到新canvas
                  pageTableCtx.drawImage(
                    tableCanvas,
                    0, sourceY, tableCanvas.width, sourceHeight,
                    0, 0, pageTableCanvas.width, pageTableCanvas.height
                  );
                  
                  // 将裁剪后的表格部分转换为图像数据
                  const pageTableImgData = pageTableCanvas.toDataURL('image/jpeg', quality);
                  
                  // 添加裁剪后的表格部分
                  pdf.addImage(
                    pageTableImgData, 
                    'JPEG',
                    margins.left,
                    yOffset, 
                    contentWidth, 
                    tablePartHeight
                  );
                  
                  yOffset += tablePartHeight;
                }
              } catch (e) {
                console.warn('处理表格页码时出错:', e);
              }
            }
            
            // 添加页码（如果页数大于1）
            if (pagesNeeded > 1) {
              // 使用英文格式页码，避免中文乱码问题
              try {
                pdf.setFontSize(9);
                pdf.setTextColor(100, 100, 100);
                
                // 使用英文格式页码
                pdf.text(
                  `Page ${page + 1} / ${pagesNeeded}`, 
                  pageWidth / 2, 
                  pageHeight - 5, 
                  { align: 'center' }
                );
              } catch (e) {
                console.warn('页码渲染失败:', e);
              }
            }
            
            // 添加表尾（只在最后一页显示）
            if (footerImgData && page === pagesNeeded - 1) {
              pdf.addImage(
                footerImgData, 
                'JPEG', 
                margins.left, 
                pageHeight - margins.bottom - footerHeight, 
                contentWidth, 
                footerHeight
              );
            }
          }
        } catch (e) {
          console.warn('处理表格时出错:', e);
          // 降级处理：使用html2canvas对整个元素截图
          const canvas = await html2canvas(tempContainer, {
            scale: 1.5,
            useCORS: true,
            logging: false,
            allowTaint: true,
            backgroundColor: '#FFFFFF'
          });
          
          const imgData = canvas.toDataURL('image/jpeg', quality);
          const imgWidth = contentWidth;
          const imgHeight = (canvas.height / canvas.width) * imgWidth;
          
          pdf.addImage(imgData, 'JPEG', margins.left, margins.top, imgWidth, imgHeight);
        }
      }
      
      // 添加水印
      if (watermark) {
        try {
          // 设置水印样式
          pdf.setFontSize(48);
          pdf.setTextColor(200, 200, 200);
          
          // 添加水印文字
          pdf.text(
            watermark, 
            pageWidth / 2, 
            pageHeight / 2, 
            { 
              align: 'center', 
              angle: 45,
              renderingMode: 'stroke'
            }
          );
        } catch (e) {
          console.warn('添加水印失败:', e);
        }
      }
      
      // 清理临时元素
      document.body.removeChild(tempContainer);
      
      // 恢复原始滚动位置
      element.scrollTop = originalScrollTop;
      
      // 保存文件
      pdf.save(`${fileName}.pdf`);
      
      return Promise.resolve();
    } catch (error) {
      console.error('PDF导出失败:', error);
      return Promise.reject(error);
    }
  }
}
